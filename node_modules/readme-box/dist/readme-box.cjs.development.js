'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var request = require('@octokit/request');

var ReadmeBox = /*#__PURE__*/function () {
  function ReadmeBox(opts) {
    this.owner = opts.owner;
    this.repo = opts.repo;
    this.token = opts.token;
    this.branch = opts.branch || 'master';
    this.request = request.request.defaults({
      headers: {
        authorization: "token " + this.token
      }
    });
  }

  ReadmeBox.updateSection = function updateSection(newContents, opts) {
    try {
      var box = new ReadmeBox(opts); // Get the README

      return Promise.resolve(box.getReadme()).then(function (_ref) {
        var content = _ref.content,
            sha = _ref.sha,
            path = _ref.path;
        // Replace the old contents with the new
        var replaced = box.replaceSection({
          section: opts.section,
          oldContents: content,
          newContents: newContents
        }); // Actually update the README

        return box.updateReadme({
          content: replaced,
          message: opts.message,
          branch: opts.branch,
          sha: sha,
          path: path
        });
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  var _proto = ReadmeBox.prototype;

  _proto.getReadme = function getReadme() {
    try {
      var _this2 = this;

      return Promise.resolve(_this2.request('GET /repos/:owner/:repo/readme', {
        owner: _this2.owner,
        repo: _this2.repo,
        ref: _this2.branch
      })).then(function (_ref2) {
        var data = _ref2.data;
        // The API returns the blob as base64 encoded, we need to decode it
        var encoded = data.content;
        var decoded = Buffer.from(encoded, 'base64').toString('utf8');
        return {
          content: decoded,
          sha: data.sha,
          path: data.path
        };
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.updateReadme = function updateReadme(opts) {
    try {
      var _this4 = this;

      return Promise.resolve(_this4.request('PUT /repos/:owner/:repo/contents/:path', {
        owner: _this4.owner,
        repo: _this4.repo,
        content: Buffer.from(opts.content).toString('base64'),
        path: opts.path || 'README.md',
        message: opts.message || 'Updating the README!',
        sha: opts.sha,
        branch: opts.branch || 'master'
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };

  _proto.getSection = function getSection(section, content) {
    var _match$groups;

    var _this$createRegExp = this.createRegExp(section),
        regex = _this$createRegExp.regex;

    var match = content.match(regex);
    return match === null || match === void 0 ? void 0 : (_match$groups = match.groups) === null || _match$groups === void 0 ? void 0 : _match$groups.content;
  };

  _proto.replaceSection = function replaceSection(opts) {
    var _this$createRegExp2 = this.createRegExp(opts.section),
        regex = _this$createRegExp2.regex,
        start = _this$createRegExp2.start,
        end = _this$createRegExp2.end;

    if (!regex.test(opts.oldContents)) {
      throw new Error("Contents do not contain start/end comments for section \"" + opts.section + "\"");
    }

    var newContentsWithComments = start + "\n" + opts.newContents + "\n" + end;
    return opts.oldContents.replace(regex, newContentsWithComments);
  };

  _proto.createRegExp = function createRegExp(section) {
    var start = "<!--START_SECTION:" + section + "-->";
    var end = "<!--END_SECTION:" + section + "-->";
    var regex = new RegExp(start + "\n(?:(?<content>[\\s\\S]+)\n)?" + end);
    return {
      regex: regex,
      start: start,
      end: end
    };
  };

  return ReadmeBox;
}();

exports.ReadmeBox = ReadmeBox;
//# sourceMappingURL=readme-box.cjs.development.js.map
